/***********************************************************************************
ComInterpNodes.h  -  series of functions to communicate interpolation data among processors
                            -------------------
developers: Stefano Markidis, Enrico Camporeale, Giovanni Lapenta,  David Burgess
***************************************************************************/

#ifndef ComInterpNodes_H
#define ComInterpNodes_H

#include "ComBasic.h"

/**
* 
* series of functions to communicate interpolation data among processors 
* @date Fri Jun 4 2007
* @author Stefano Markidis, Giovanni Lapenta, Enrico Camporeale, David Burgess
* @version 2.0
*
*/

/**SPECIES: communicate ghost cells and sum the contribution with a index indicating the number of species */
inline void communicateInterp(int nx, int ny, int ns, double ****vector, int bcFaceXright, int bcFaceXleft, int bcFaceYright, int bcFaceYleft,double dx, double dy, VirtualTopology *vct){
  // allocate 6 ghost cell Faces
  double *ghostXrightFace = new double[ny-2];
  double *ghostXleftFace  = new double[ny-2];
  double *ghostYrightFace = new double[nx-2];
  double *ghostYleftFace  = new double[nx-2];
  
  // allocate 4 Node corners
  double ghostXrightYrightCorner, ghostXleftYrightCorner, ghostXrightYleftCorner, ghostXleftYleftCorner;
  
  makeNodeFaceInterp(nx, ny, vector, ns, ghostXrightFace, ghostXleftFace, ghostYrightFace, ghostYleftFace);

  makeNodeCornerInterp(nx,ny, vector, ns, &ghostXrightYrightCorner, &ghostXleftYrightCorner, &ghostXrightYleftCorner, &ghostXleftYleftCorner);
  
  communicateGhostFace(ny-2,vct->getCartesian_rank(),vct->getXright_neighbor(),vct->getXleft_neighbor(),0,vct->getXLEN(),vct->getYLEN(),ghostXrightFace, ghostXleftFace);
  communicateGhostFace(nx-2,vct->getCartesian_rank(),vct->getYright_neighbor(),vct->getYleft_neighbor(),1,vct->getXLEN(),vct->getYLEN(),ghostYrightFace, ghostYleftFace);
  
  addGhostFace(nx,ny,ns,vector,ghostXrightFace,ghostXleftFace,ghostYrightFace,ghostYleftFace,vct);


 communicateGhostCorner(vct->getCartesian_rank(), vct->getXrightYright_neighbor(), vct->getXleftYleft_neighbor(), vct->getXLEN(),vct->getYLEN(), &ghostXrightYrightCorner, &ghostXleftYleftCorner);
 communicateGhostCorner(vct->getCartesian_rank(), vct->getXrightYleft_neighbor(),  vct->getXleftYright_neighbor(), vct->getXLEN(),vct->getYLEN(), &ghostXrightYleftCorner, &ghostXleftYrightCorner);
  
 addGhostCorner(nx,ny, ns, vector, &ghostXrightYrightCorner, &ghostXleftYrightCorner, &ghostXrightYleftCorner, &ghostXleftYleftCorner, vct);
  

  
  delete[] ghostXrightFace;
  delete[] ghostXleftFace;
  delete[] ghostYrightFace;
  delete[] ghostYleftFace;
    

}

/**SPECIES: communicate ghost cells and sum the contribution with a index indicating the number of species in 1D*/
inline void communicateInterp(int nx,int ns,double ****vector, int bcFaceXright, int bcFaceXleft,double dx, VirtualTopology *vct){
  // allocate 2 ghost cells
  double ghostXright,ghostXleft;
  // prepare the physical values values an put them in a buffer
  makeCenterCornerInterp(nx,vector,ns,&ghostXright,&ghostXleft);
  // communicate the corners
  communicateGhostCorner(vct->getCartesian_rank(),vct->getXright_neighbor(),vct->getXleft_neighbor(),vct->getXLEN(), &ghostXright,&ghostXleft);
  // add to the interpolated values
  addGhostCornerCenter(nx,ns,vector,&ghostXright,&ghostXleft,vct);
}














#endif
