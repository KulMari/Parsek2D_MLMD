/***********************************************************************************
ComNodes.h  -  series of functions to communicate the values on nodes on processors
                            -------------------
developers: Stefano Markidis, Giovanni Lapenta
***************************************************************************/

#ifndef ComNodes_H
#define ComNodes_H

#include "ComBasic.h"
#include "../bc/BcFields.h"


/**
* 
* Prepare the ghost cells with nodes values, communicate the ghost cells, and replace the values on the ghost cells
* @date Fri Jun 4 2008
* @author Stefano Markidis, Giovanni Lapenta
* @version 2.0
*
*/
/** communicate ghost node values among processors in 1D*/
inline void communicateNode(int nx,double ***vector,VirtualTopology *vct){
  // allocate 2 ghost cells
  double ghostXright,ghostXleft;
  // prepare the physical values values an put them in a buffer
  makeNodeCorner(nx,vector,&ghostXright,&ghostXleft);
  // communicate the corners
  communicateGhostCorner(vct->getCartesian_rank(), vct->getXright_neighbor(),vct->getXleft_neighbor(),vct->getXLEN(), &ghostXright, &ghostXleft);
  // take the values from the buffer and put it back to the edge ghost cells
  parseCorner(nx,vector,&ghostXright,&ghostXleft);
}

/** communicate ghost node values among processors in 2D*/
inline void communicateNode(int nx, int ny, double ***vector, VirtualTopology *vct){
  // allocate 4 ghost cell Faces
  double *ghostXrightFace = new double[ny-2];
  double *ghostXleftFace  = new double[ny-2];
  double *ghostYrightFace = new double[nx-2];
  double *ghostYleftFace  = new double[nx-2];
  
  // allocate 4 ghost cell corner
  double ghostXrightYrightCorner,ghostXleftYrightCorner,ghostXrightYleftCorner,ghostXleftYleftCorner;
  // prepare the values an put in a buffer
  makeNodeFaceX(nx,ny,vector,ghostXrightFace,ghostXleftFace,vct);
  makeNodeFaceY(nx,ny,vector,ghostYrightFace,ghostYleftFace,vct);
  makeNodeCorner(nx,ny, vector, &ghostXrightYrightCorner, &ghostXleftYrightCorner, &ghostXrightYleftCorner, &ghostXleftYleftCorner,vct);
  // communication of edges
  communicateGhostFace((ny-2),vct->getCartesian_rank(),vct->getXright_neighbor(),vct->getXleft_neighbor(),0,vct->getXLEN(),vct->getYLEN(),ghostXrightFace, ghostXleftFace);
  communicateGhostFace((nx-2),vct->getCartesian_rank(),vct->getYright_neighbor(),vct->getYleft_neighbor(),1,vct->getXLEN(),vct->getYLEN(),ghostYrightFace, ghostYleftFace);
  // take the values from the buffer and put it back to the edge ghost cells
  parseFaceX(nx,ny,vector,ghostXrightFace,ghostXleftFace);
  parseFaceY(nx,ny,vector,ghostYrightFace,ghostYleftFace);

  // communicate the corners
  communicateGhostCorner(vct->getCartesian_rank(), vct->getXrightYright_neighbor(), vct->getXleftYleft_neighbor(), vct->getXLEN(),vct->getYLEN(), &ghostXrightYrightCorner, &ghostXleftYleftCorner);
  communicateGhostCorner(vct->getCartesian_rank(), vct->getXrightYleft_neighbor(),  vct->getXleftYright_neighbor(), vct->getXLEN(),vct->getYLEN(), &ghostXrightYleftCorner, &ghostXleftYrightCorner);
  // take the values from the buffer and put it back to the edge ghost cells
  parseCorner(nx,ny,vector, &ghostXrightYrightCorner, &ghostXleftYrightCorner, &ghostXrightYleftCorner, &ghostXleftYleftCorner);
	  

  delete[] ghostXrightFace;
  delete[] ghostXleftFace;
  delete[] ghostYrightFace;
  delete[] ghostYleftFace;
    
}
/**SPECIES: communicate ghost node values among processors 1D*/
inline void communicateNode(int nx,double ****vector,int ns, VirtualTopology *vct){
  // allocate 2 ghost cells
  double ghostXright,ghostXleft;
  // prepare the physical values values an put them in a buffer
  makeNodeCorner(nx,vector,ns,&ghostXright,&ghostXleft);
  // communicate the corners
  communicateGhostCorner(vct->getCartesian_rank(), vct->getXright_neighbor(),vct->getXleft_neighbor(),vct->getXLEN(), &ghostXright, &ghostXleft);
  // take the values from the buffer and put it back to the edge ghost cells
  parseCorner(nx,vector,ns,&ghostXright,&ghostXleft);
}

/**SPECIES: communicate ghost node values among processors in 2D*/
inline void communicateNode(int nx, int ny, double ****vector, int ns, VirtualTopology *vct){
  // allocate 4 ghost cell Faces
	double *ghostXrightFace = new double[ny-2];
	double *ghostXleftFace  = new double[ny-2];
	double *ghostYrightFace = new double[nx-2];
	double *ghostYleftFace  = new double[nx-2];
  
  // allocate 4 ghost cell corner
	double ghostXrightYrightCorner,ghostXleftYrightCorner,ghostXrightYleftCorner,ghostXleftYleftCorner;
  
	makeNodeFaceX(nx,ny,vector, ns,ghostXrightFace,ghostXleftFace,vct);
	makeNodeFaceY(nx,ny,vector, ns,ghostYrightFace,ghostYleftFace,vct);
  
	makeNodeCorner(nx,ny, vector, ns, &ghostXrightYrightCorner, &ghostXleftYrightCorner, &ghostXrightYleftCorner,&ghostXleftYleftCorner,vct);
  
	communicateGhostFace((ny-2),vct->getCartesian_rank(),vct->getXright_neighbor(),vct->getXleft_neighbor(),0,vct->getXLEN(),vct->getYLEN(),ghostXrightFace, ghostXleftFace);
	communicateGhostFace((nx-2),vct->getCartesian_rank(),vct->getYright_neighbor(),vct->getYleft_neighbor(),1,vct->getXLEN(),vct->getYLEN(),ghostYrightFace, ghostYleftFace);
  
	parseFaceX(nx,ny,vector,ns,ghostXrightFace,ghostXleftFace);
	parseFaceY(nx,ny,vector,ns,ghostYrightFace,ghostYleftFace);


	communicateGhostCorner(vct->getCartesian_rank(), vct->getXrightYright_neighbor(), vct->getXleftYleft_neighbor(), vct->getXLEN(),vct->getYLEN(), &ghostXrightYrightCorner, &ghostXleftYleftCorner);
	communicateGhostCorner(vct->getCartesian_rank(), vct->getXrightYleft_neighbor(),  vct->getXleftYright_neighbor(), vct->getXLEN(),vct->getYLEN(), &ghostXrightYleftCorner, &ghostXleftYrightCorner);

	parseCorner(nx,ny,vector, ns, &ghostXrightYrightCorner, &ghostXleftYrightCorner, &ghostXrightYleftCorner, &ghostXleftYleftCorner);
	  

	delete[] ghostXrightFace;
	delete[] ghostXleftFace;
	delete[] ghostYrightFace;
	delete[] ghostYleftFace;
    
}


/** communicate ghost center values among processors in 1D*/
inline void communicateCenter(int nx, double ***vector, VirtualTopology *vct){
  // allocate 2 ghost cells
  double ghostXright,ghostXleft;
  // prepare the physical values values an put them in a buffer
  makeCenterCorner(nx,vector,&ghostXright,&ghostXleft);
  // communicate the corners
  communicateGhostCorner(vct->getCartesian_rank(),vct->getXright_neighbor(),vct->getXleft_neighbor(),vct->getXLEN(), &ghostXright, &ghostXleft);
  // take the values from the buffer and put it back to the edge ghost cells
  parseCorner(nx,vector,&ghostXright,&ghostXleft);
    
}
/** communicate ghost center values among processors in 2D*/
inline void communicateCenter(int nx, int ny, double ***vector, VirtualTopology *vct){
   // allocate 4 ghost cell Faces
	double *ghostXrightFace = new double[ny-2];
	double *ghostXleftFace  = new double[ny-2];
	double *ghostYrightFace = new double[nx-2];
	double *ghostYleftFace  = new double[nx-2];
  
  // allocate 4 ghost cell corner
	double ghostXrightYrightCorner,ghostXleftYrightCorner,ghostXrightYleftCorner,ghostXleftYleftCorner;
  
	makeCenterFaceX(nx,ny,vector,ghostXrightFace,ghostXleftFace,vct);
	makeCenterFaceY(nx,ny,vector,ghostYrightFace,ghostYleftFace,vct);
	makeCenterCorner(nx,ny, vector, &ghostXrightYrightCorner, &ghostXleftYrightCorner, &ghostXrightYleftCorner, &ghostXleftYleftCorner,vct);

  
	communicateGhostFace((ny-2),vct->getCartesian_rank(),vct->getXright_neighbor(),vct->getXleft_neighbor(),0,vct->getXLEN(),vct->getYLEN(),ghostXrightFace, ghostXleftFace);
	communicateGhostFace((nx-2),vct->getCartesian_rank(),vct->getYright_neighbor(),vct->getYleft_neighbor(),1,vct->getXLEN(),vct->getYLEN(),ghostYrightFace, ghostYleftFace);
	
	parseFaceX(nx,ny,vector,ghostXrightFace,ghostXleftFace);
	parseFaceY(nx,ny,vector,ghostYrightFace,ghostYleftFace);
	
	
	communicateGhostCorner(vct->getCartesian_rank(), vct->getXrightYright_neighbor(), vct->getXleftYleft_neighbor(), vct->getXLEN(),vct->getYLEN(), &ghostXrightYrightCorner, &ghostXleftYleftCorner);
	communicateGhostCorner(vct->getCartesian_rank(), vct->getXrightYleft_neighbor(),  vct->getXleftYright_neighbor(), vct->getXLEN(),vct->getYLEN(), &ghostXrightYleftCorner, &ghostXleftYrightCorner);

	parseCorner(nx,ny,vector, &ghostXrightYrightCorner, &ghostXleftYrightCorner, &ghostXrightYleftCorner, &ghostXleftYleftCorner);
	  

	delete[] ghostXrightFace;
	delete[] ghostXleftFace;
	delete[] ghostYrightFace;
	delete[] ghostYleftFace;
    
}
/** SPECIES: communicate ghost center values among processors in 1D*/
inline void communicateCenter(int nx,double ****vector,int ns,VirtualTopology *vct){
  // allocate 2 ghost cells
  double ghostXright,ghostXleft;
  // prepare the physical values values an put them in a buffer
  makeCenterCorner(nx,vector,ns,&ghostXright,&ghostXleft);
  // communicate the corners
  communicateGhostCorner(vct->getCartesian_rank(), vct->getXright_neighbor(),vct->getXleft_neighbor(),vct->getXLEN(), &ghostXright, &ghostXleft);
  // take the values from the buffer and put it back to the edge ghost cells
  parseCorner(nx,vector,ns,&ghostXright,&ghostXleft);
	
    
}
/** SPECIES: communicate ghost center values among processors in 2D*/
inline void communicateCenter(int nx, int ny, double ****vector, int ns,VirtualTopology *vct){
  // allocate 4 ghost cell Faces
	double *ghostXrightFace = new double[ny-2];
	double *ghostXleftFace  = new double[ny-2];
	double *ghostYrightFace = new double[nx-2];
	double *ghostYleftFace  = new double[nx-2];
  
  // allocate 4 ghost cell corner
	double ghostXrightYrightCorner,ghostXleftYrightCorner,ghostXrightYleftCorner,ghostXleftYleftCorner;
  
	makeCenterFaceX(nx,ny,vector,ns,ghostXrightFace,ghostXleftFace,vct);
	makeCenterFaceY(nx,ny,vector,ns,ghostYrightFace,ghostYleftFace,vct);
	makeCenterCorner(nx,ny, vector, ns,&ghostXrightYrightCorner, &ghostXleftYrightCorner, &ghostXrightYleftCorner, &ghostXleftYleftCorner,vct);

  
	communicateGhostFace((ny-2),vct->getCartesian_rank(),vct->getXright_neighbor(),vct->getXleft_neighbor(),0,vct->getXLEN(),vct->getYLEN(),ghostXrightFace, ghostXleftFace);
	communicateGhostFace((nx-2),vct->getCartesian_rank(),vct->getYright_neighbor(),vct->getYleft_neighbor(),1,vct->getXLEN(),vct->getYLEN(),ghostYrightFace, ghostYleftFace);
	
	parseFaceX(nx,ny,vector, ns, ghostXrightFace,ghostXleftFace);
	parseFaceY(nx,ny,vector, ns, ghostYrightFace,ghostYleftFace);
	
	
	communicateGhostCorner(vct->getCartesian_rank(), vct->getXrightYright_neighbor(), vct->getXleftYleft_neighbor(), vct->getXLEN(),vct->getYLEN(), &ghostXrightYrightCorner, &ghostXleftYleftCorner);
	communicateGhostCorner(vct->getCartesian_rank(), vct->getXrightYleft_neighbor(),  vct->getXleftYright_neighbor(), vct->getXLEN(),vct->getYLEN(), &ghostXrightYleftCorner, &ghostXleftYrightCorner);

	parseCorner(nx,ny,vector, ns, &ghostXrightYrightCorner, &ghostXleftYrightCorner, &ghostXrightYleftCorner, &ghostXleftYleftCorner);
	  

	delete[] ghostXrightFace;
	delete[] ghostXleftFace;
	delete[] ghostYrightFace;
	delete[] ghostYleftFace;
    
}


#endif
